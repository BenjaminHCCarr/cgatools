// Copyright 2010 Complete Genomics, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you
// may not use this file except in compliance with the License. You
// may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

#include "cgatools/core.hpp"

#include "cgatools/reference/ChromosomeIdField.hpp"
#include "cgatools/mapping/EvidenceCache.hpp"
#include "cgatools/mapping/AlleleAlignment.hpp"
#include "cgatools/mapping/LibraryData.hpp"
#include <math.h>

#include <boost/foreach.hpp>

namespace cgatools { namespace mapping {


void CacheOutStreams::writeMetadata(
    std::ostream &output, const std::string& slide, const std::string& lane, size_t batchNo) const
{
    OutLaneBatchStreams::writeMetadata(output, slide, lane, batchNo);

    output
        << '>'  << "DnbOffsetInLaneFile"
        << '\t' << "IntervalId"
        << '\t' << "AlleleIndex"
        << '\t' << "Chromosome"
        << '\t' << "Side"
        << '\t' << "Strand"
        << '\t' << "OffsetInAllele"
        << '\t' << "AlleleAlignment"
        << '\t' << "OffsetInReference"
        << '\t' << "ReferenceAlignment"
        << '\t' << "MateOffsetInReference"
        << '\t' << "MateReferenceAlignment"
        << '\t' << "MappingQuality"
        << '\t' << "AlleleConcordance"
        << std::endl;
}

void EvidenceCacheBuilder::processChrData(uint16_t chr, 
    const boost::filesystem::path& outputPrefix, const util::FastRangeSet::RangeSet &exportRanges)
{
    CGA_ASSERT(!exportRanges.empty());

    std::string chrName = reference_.listChromosomes()[chr].getName();
    CacheOutStreams outStreams(outputPrefix/chrName);
    cgdata::EvidenceReader reader(reference_,genomeMetadata_);
    reader.seekToChr(chr);

    AlleleSequenceAligner       alleleAligner(reference_);
    size_t lastPositionInRangeSet = exportRanges.rbegin()->second;

    for (;reader.inInterval();reader.nextInChr())
    {
        const cgdata::EvidenceReader::IntervalRecord& interval = reader.getInterval();
        if (interval.offset_>lastPositionInRangeSet)
            break;
        if (!exportRanges.intersects(std::make_pair(interval.offset_,interval.offset_+interval.length_)))
            continue;

        const std::vector<cgdata::EvidenceReader::DnbRecord>& dnbs = reader.getDnbs();
        BOOST_FOREACH(const cgdata::EvidenceReader::DnbRecord& dnb, dnbs)
        {
            alleleAligner.setInterval(interval.chromosome_,interval.offset_,
                interval.length_, &interval.alleles_[dnb.alleleIndex_]);

            const LibraryData& lib = libraries_->getLibraryData(dnb.slide_+"-"+dnb.lane_);
            GapProbabilityAndConcordanceExtractor  gapConcordanceExtractor(alleleAligner, 
                lib.gapsEstimators_);
            gapConcordanceExtractor.run(dnb.side_,dnb.strand_,
                dnb.offsetInAllele_,dnb.alleleAlignment_,dnb.sequence_,dnb.scores_);

            double mapWeight = gapConcordanceExtractor.concordance_ * 
                                    gapConcordanceExtractor.gapProbability_;

            #ifdef _TEST_MAPQ_ //Check mapping quality

                //Compare the mapping quality with the one generated by assembly

                size_t mateGapSize = abs(dnb.offsetInReference_[0]-dnb.offsetInReference_[1]);
                double mateGapFrequency =
                    mateGapTable_->getFrequency(mateGapSize);

                AlleleSequenceAligner mateAlleleAligner(reference_);
                mateAlleleAligner.setInterval(dnb.chromosome_, 0, 0, NULL);
                GapProbabilityAndConcordanceExtractor 
                    mateConcordanceExtractor(mateAlleleAligner,gapsEstimators_);
                mateConcordanceExtractor.run(1-dnb.side_, dnb.strand_, dnb.offsetInReference_[1], 
                    dnb.referenceAlignment_[1], dnb.sequence_, dnb.scores_);

                double mapWeight1 = mateConcordanceExtractor.concordance_ * 
                                            mateConcordanceExtractor.gapProbability_;

                double fullMapWeight = mapWeight*mapWeight1*mateGapFrequency;
                double alpha = 1E-9;
                double singleMappingMapQ0 = alpha/(alpha+fullMapWeight);
                double mapq = -10*log10(singleMappingMapQ0);
                double mapqOrig = dnb.mappingQuality_-33;

            #endif //Check mapping quality

            std::ostream& osr = outStreams.getBatchStream(dnb.slide_,dnb.lane_,dnb.fileNumInLane_);
            osr << dnb.dnbOffsetInLaneFile_ 
                << '\t' << dnb.intervalId_
                << '\t' << int(dnb.alleleIndex_)
                << '\t' << reference_.listChromosomes()[dnb.chromosome_].getName()
                << '\t' << "LR"[dnb.side_]
                << '\t' << "+-"[size_t(dnb.strand_)]
                << '\t' << dnb.offsetInAllele_
                << '\t' << dnb.alleleAlignment_
                << '\t' << dnb.offsetInReference_[0]
                << '\t' << dnb.referenceAlignment_[0]
                << '\t' << dnb.offsetInReference_[1]
                << '\t' << dnb.referenceAlignment_[1]
                << '\t' << dnb.mappingQuality_
                << '\t' << mapWeight
                ;
            osr << std::endl;
        }
    }
}

void EvidenceCacheBuilder::exportRanges(
    const boost::filesystem::path& outputPrefix, const util::FastRangeSet& ranges)
{
    for (size_t i=0; i<ranges.getRanges().size(); ++i)
        if (!ranges.getRanges()[i].empty())
            processChrData(i,outputPrefix,ranges.getRanges()[i]);
}

EvidenceCacheBuilder::EvidenceCacheBuilder( const cgdata::GenomeMetadata& genomeMetadata,
                                           const reference::CrrFile& reference ) 
    : genomeMetadata_(genomeMetadata), reference_(reference)
{
    libraries_.reset(new LibraryMetadataContainer(genomeMetadata,false));
}

void EvidenceCacheReader::readBatchRecords(
    const std::string& slide, const std::string& lane, size_t batchNo,
    BatchRecords& result, const reference::CrrFile& crr)
{
    size_t loadedRecords = 0;
    const InputBatchFiles& files = inputBatches_.getBatchFiles(slide, lane, batchNo);
    BOOST_FOREACH(const boost::filesystem::path& file, files)
    {
        boost::shared_ptr<std::istream> inStream 
            = util::InputStream::openCompressedInputStreamByExtension(file.string());
        util::DelimitedFile parser(*inStream, file.string());
        EvidenceCacheDnbRecord record;
        initCacheRecordParser(parser,record,crr);
        const std::string &slide = parser.getMetadata().get("SLIDE");
        const std::string &lane = parser.getMetadata().get("LANE");
        uint16_t fileNum = parser.getMetadata().get<uint16_t>("BATCH_FILE_NUMBER");
        while (parser.next()) 
        {
            record.slide_ = slide;
            record.lane_ = lane;
            record.fileNumInLane_ = fileNum;
            result.insert(BatchRecords::value_type(record.dnbOffsetInLaneFile_,record));
            ++loadedRecords;
        }
    }
    std::cerr   << "Processed evidence cache files: " << files.size() 
                << " loaded records: " << loadedRecords << std::endl;
}

void EvidenceCacheReader::initCacheRecordParser( 
    util::DelimitedFile &delimitedFile, EvidenceCacheDnbRecord& record, const reference::CrrFile& crr)
{
    delimitedFile.addField(util::ValueField<uint32_t>("DnbOffsetInLaneFile",&record.dnbOffsetInLaneFile_));
    delimitedFile.addField(util::ValueField<int32_t>("IntervalId",&record.intervalId_));
    delimitedFile.addField(util::ValueField<uint8_t>("AlleleIndex",&record.alleleIndex_));
    delimitedFile.addField(reference::ChromosomeIdField("Chromosome",&record.chromosome_, crr));
    delimitedFile.addField(util::SideField("Side",&record.side_));
    delimitedFile.addField(util::StrandField("Strand",&(record.strand_)));
    delimitedFile.addField(util::ValueField<int32_t>("OffsetInAllele",&record.offsetInAllele_));
    delimitedFile.addField(util::StringField("AlleleAlignment",&record.alleleAlignment_));
    delimitedFile.addField(util::ValueField<int32_t>("OffsetInReference",&record.offsetInReference_[0]));
    delimitedFile.addField(util::StringField("ReferenceAlignment",&record.referenceAlignment_[0]));
    delimitedFile.addField(util::ValueField<int32_t>("MateOffsetInReference",&record.offsetInReference_[1]));
    delimitedFile.addField(util::StringField("MateReferenceAlignment",&record.referenceAlignment_[1]));
    delimitedFile.addField(util::CharField("MappingQuality",(char *)&record.mappingQuality_));
    delimitedFile.addField(util::ValueField<double>("AlleleConcordance",&record.alleleConcordance_));
}

} } // cgatools::mapping
